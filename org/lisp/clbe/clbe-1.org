#+DATE: 24 July 2021

#+TITLE: Introduction

Previous: [[file:clbe-0.org][0. Preface]]

Next: [[file:clbe-2.org][2. Symbols & Data Objects]]

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

Lisp is an interactive language and all Lisp systems will include an
interactive front-end known as the toplevel. We can enter Lisp expressions
into the toplevel and Lisp will evaluate them and print their value.
This is known as the Read-Eval-Print-Loop, or REPL for short. Lisp
expressions that are meant to be evaluated are known as forms.

Atoms are the most basic unit of Lisp, representing singular objects,
such as the number =5= and the string “Hello, World!”. Lists are
collections of atoms or other lists, separated by whitespace and
enclosed in parenthesis, such as =(1 2 3)= or =(“Michael” “David”
“Ben”)=. An example of a nested list would be =((1 2 3) 4 5 6)=.

Lisp utilises prefix notation throughout the language, meaning
operators precede their arguments. As an example, we would calculate
=2 + 3 as (+ 2 3)=.

** Evaluation of Forms

Lisp applies a consistent set of evaluation rules for atomic and list
forms. It is very important to have a deep understanding of Lisp’s
evaluation rules and this is the most important section of this guide.

Atoms evaluate to themselves. For example, the number =8= appearing as
an atom within Lisp code will evaluate to =8= and the string =“Color
is gold”= will evaluate to itself. This rule also applies to atomic
symbols (discussed shortly), which will evaluate to the value bound to
the symbol or return an error if the value is unbound. Note that lists
themselves are a collection of atoms; in evaluating a list, we need to
evaluate each of the atoms individually and then apply the rules for
the evaluation of the list.

Lisp will evaluate a list by looking up its first element and
determining whether it represents the start of one of four types of
forms: function, special, macro or lambda. A list whose first element
is the symbol for a function name is known as a function form. Lisp
will evaluate the remaining elements of a function form and pass them
as arguments to the function bound to (i.e. named by) the symbol. For
example, the below form evaluates the arguments to 10, 5 and 15
respectively (each itself a result of a function), and pass them to
the function call to return 30:

#+begin_src lisp

  ;; Returns 30:

  (+ (+ 5 5) (* 5 1) (+ 10 5))

#+end_src

The evaluation rule for functions is not suitable for all
scenarios. For example, in an IF conditional, we only want the true
statement to be evaluated if the condition is true and we only want
the false statement to be evaluated if the condition is false. For
example, in the below, we only want to divide 10 by the value stored
in X if it is not zero (as otherwise we will get divide-by-zero
error). In an IF conditional, and in many other language constructs,
we do not want each element of the list to be evaluated.

#+begin_src lisp

  (defparameter x 0)

  (if (zerop X) ; Test if x = 0
      "Cannot divide as X is zero" ; Do this if x = 0
    (/ 10 X)) ; Do this if x not 0

#+end_src

Common Lisp has 25 special forms, representing primitive functions
with their own specific evaluation rules. The evaluation rule for the
IF special form is to evaluate the true statement only if the
condition is true and the false statement only if the condition is
false. We will discuss the evaluation rules for common special forms
in the remainder of this guide.

Finally, Lisp also has specific evaluation rules for macro and lambda
forms. We will discuss these forms in greater depth towards the end of
this guide. During this guide however we will sporadically introduce
some of Common Lisp’s built-in macros. For now, we can treat them
similarly to special forms, noting each macro has a specific
evaluation rule.

Try entering the following list into our toplevel. You will receive an
error. This is because Lisp will look at the first element 1 and is
unable to evaluate it as one of the four compound forms we discussed
as 1 is a number, not the name of a function, special form or macro:

#+begin_src lisp

  (1 2 3)
  
#+end_src

** Controlling Evaluation

The quote special form is used to override the above evaluation rules by
returning back the object literally without evaluation. For example, either
of the below two forms will evaluate without error as Lisp is no longer
evaluating the list =(1 2 3)=, but rather returning it literally:

#+begin_src lisp

  (quote (1 2 3))

  ;; ' is the shorthand for quote:

  '(1 2 3)

#+end_src
