#+DATE: 24 July 2021

#+TITLE: Arrays & Sequences

#+ATTR_HTML: :class nav-links
Previous: [[file:clbe-13.org][13. More on Functions]]
#+ATTR_HTML: :class nav-links
Next: [[file:clbe-15.org][15. Hash Tables]]


#+begin_theorem
If an integer $n$ is greater than 2, then the equation $a^n + b^n = c^n$
has no solutions in non-zero integers $a$, $b$, and $c$.
#+end_theorem

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

The function MAKE-ARRAY allows us to create arrays. For example, we
can create a 2 x 3 array as follows:

#+begin_src lisp

  (defparameter my-array
    (make-array '(2 3) :initial-element nil))

#+end_src

The functions AREF and SETF allow us to access elements and set them
with values:

#+begin_src lisp

  ;; Returns NIL

  (aref my-array 0 0)

  
  ;; Set (0,0) to B
  
  (setf (aref my-array 0 0) 'b)

  
  ;; Returns B

  (aref my-array 0 0)

#+end_src

The functions ARRAY-RANK and ARRAY-DIMENSION retrieve the the number
of dimensions and the number of elements in a given dimension
respectively:

#+begin_src lisp

  (setf my-array
	(make-array '(2 3)
		    :initial-element '((1 2 3) (1 2 3))))

  
  ;; Returns 2

  (array-rank my-array))


  ;; Returns 2

  (array-dimension my-array 0)
  

  ;; Returns 3

  (array-dimension my-array 1)

#+end_src

We use :INITIAL-ELEMENT to set the value of every element of an array
to the provided argument, while we use :INITIAL-CONTENTS to set the
array to the object provided. A one-dimensional array is a vector and
can be created with either of the following.

#+begin_src lisp

(vector "a" 'b 3)
 
(defparameter my-vector
  (make-array 3 :initial-contents '("a" 'b 3)))

#+end_src

Finally, we can create a literal array using the #na syntax, where n
is the number of dimensions:

#+begin_src lisp

  ;; Returns ((B NIL NIL) (1 2 3))

  #2a((b nil nil) (1 2 3))

#+end_src
	
Strings are vectors of characters, denoted with double quotes
(e.g. "my-string"). Strings evaluate to themselves. A character such
as c is denoted as #\c. Each character has an associated integer that
is usually (but not necessarily) its ASCII number:

#+begin_src lisp

  ;; Returns 99
  
  (char-code #\c)

  ;; Returns #\c
  
  (code-char 99) 

#+end_src

* Sequences

The type sequence includes both lists and vectors (and therefore
strings). Sequences have many useful functions:

#+begin_src lisp

  ;; Returns 6

  (length '(a b c d e f))

  ;; Returns (F E D C B A)

  (reverse '(a b c d e f)) 

  ;; Returns (C R T) (a new original list unaffected):

  (remove 'a '(c a r a t))
 	
  ;; Returns "cbdra" (preserves only the last of each):

  (remove-duplicates "abracadabra")

#+end_src

We use SUBSEQ to get a portion of a list. Its arguments are a list,
the starting position and an optional ending position (which is not to
be included in the subsequence):

#+begin_src lisp

  ;; Returns (B C D)
  
  (subseq '(a b c d e f) 1 4)

#+end_src

SORT takes a sequence and a comparison function of two arguments and
destructively (i.e. by modifying the original sequence) returns a
sequence sorted according to the function:

#+begin_src lisp

  ;; Returns (6 5 4 2 1)
  
  (sort '(1 4 2 5 6) #'>) 

#+end_src

The functions EVERY and SOME test whether a sequence satisfies a
provided predicate:

#+begin_src lisp

  ;; Returns NIL

  (every #'oddp '( 1 2 5)) 

  ;; Returns T

  (some #'oddp '( 1 2 5))

  ;; Returns T

  (every #'> '(1 3 5) '(0 2 4))

#+end_src


* Keyword Arguments

Many sequence functions take one or more keyword arguments from the
below table. For example, we can use POSITION to return the position
of an element within a sequence (or NIL if not found) and use keyword
arguments to determine where to begin the search:

	(position #\a "fantasia" :start 3 :end 7) ; Returns 4

| Parameter | Position                            | Default  |
|-----------+-------------------------------------+----------|
| :key      | A function to apply to each element | identity |
| :test     | The test function for comparison    | eql      |
| :from-end | If true, work backwards             | nil      |
| :start    | Position at which to start          | 0        |
| :end      | Position, if any, at which to stop  | nil      |


The function REDUCE is useful to extend functions that only take two
variables. It takes two arguments, a function (which must take exactly
two values) and a sequence. The function is initially called on the
first two elements of the sequence, and thereafter with each
successive element as the second argument. The value returned by the
last call is the value returned by the REDUCE function. For example,
the below returns (A), the intersection of these three lists:

#+begin_src lisp

(reduce #'intersection '((b r a d) (b a d) (c a t)))

#+end_src
