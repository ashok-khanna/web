#+DATE: 24 July 2021

#+TITLE: Scope & Extent

Previous: [[file:clbe-18.org][18. Advanced Looping]]

Next: [[file:clbe-20.org][20. Packages]]

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

We will briefly introduce and discuss the concepts of scope and
extent. Before we begin, as a general rule, local variables and
functions (defined by LET, LET*, LABELS, FLET) can only be accessed
within their closures, whilst global names (defined by DEFVAR,
DEFPARAMETER, DEFCONSTANT, DEFUN) are accessible everywhere.

It is best practice to avoid using the same names for local and global
variables and functions.

Scope refers to the textual region of the program within which
references may occur, whilst extent refers to the interval of time
during which references may occur. For example, the scope of the
parameter X in the below is the body of the DEFUN form and its extent
is the interval from the time the function is invoked to the time it
is exited:

#+begin_src lisp

  (defun copy-cell (x)
    (cons (car x)
	  (cdr x)))

#+end_src

Accordingly, there are four permutations of scope and extent as listed
below.

1. Lexical scope: Here references to the established entity can occur
   only within certain program portions that are lexically (that is,
   textually) contained within the establishing construct. Typically the
   construct will have a part designated the body, and the scope of all
   entities established will be (or include) the body.

2. Indefinite scope: References may occur anywhere, in any program.

3. Dynamic extent: References may occur at any time in the interval
   between establishment of the entity and the explicit disestablishment
   of the entity. As a rule, the entity is disestablished when execution
   of the establishing construct completes or is otherwise terminated.
 
4. Indefinite extent: The entity continues to exist as long as the
   possibility of reference remains. (An implementation is free to
   destroy the entity if it can prove that reference to it is no longer
   possible. Garbage collection strategies implicitly employ such
   proofs.)

Variable bindings and bindings of local function names have lexical
scope and indefinite extent, whilst bindings declared to be special
(such as DEFVAR and DEFPARAMETER) have “dynamic scope” (indefinite
scope and dynamic extent). Named constants such as NIL and PI have
indefinite scope and indefinite extent.

The binding rule for dynamic scope in Lisp is as follows: a use of a
name is bound to the most recent declaration of that name that is
still live (i.e. we first look for a local definition of a variable,
if it isn’t found, we look up the calling stack for a definition).
