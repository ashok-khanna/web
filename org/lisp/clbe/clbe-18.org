#+DATE: 24 July 2021

#+TITLE: Advanced Looping

Previous: [[file:clbe-17.org][17. Reading & Writing to Files]]

Next: [[file:clbe-19.org][19. Scope & Extent]]

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

The DO macro is a very powerful and flexible iterator. It looks like
this:

#+begin_src lisp

  (do ((var1 init1 step1)
       ...
       (varn initn stepn))
      (end-test result-forms*)
    body-forms*)

#+end_src

Below is an example of the DO loop, together with a detailed step
through. This example will return 81 and print 1, 0, 1, 4, 9, 16, 25,
36, 49 and 64 on newlines. During each iteration, loop-step is
increased by one while square is set to the square of loop-step.

#+begin_src lisp

  (do ((loop-step 0 (+ loop-step 1))
       (square 1 (* loop-step loop-step)))
      ((= 10 loop-step) square) ; Stop at 10
    (print square)) ; Print square at each step

#+end_src

* Step Through

The init forms are evaluated at the beginning of the loop and bound to
the variables. In the above example, loop-step is bound to 0 while
square is bound to 1.

The end-test form is evaluated at the beginning of each iteration. If
it evaluates to NIL, the iteration proceeds and the body of the loop
is executed. Hence, in the above example you see 1 printed on the
first iteration, as that is the starting value of the square variable.

After all the body forms have been evaluated, and before each
subsequent iteration of the loop, the step forms will be evaluated and
their values will be bound to the variables.

In a DO loop, the step forms can refer to other variables defined by
the loop, but the value they receive for these variables is the value
before the step forms are evaluated. Thus, in the first update, square
is set to 0 as that is the value of loop-step before the step forms
are evaluated.

This can be seen in the printed output of 0 provided by the second
iteration of the loop.

Note in a DO loop, the init forms cannot refer to other variables
defined in the loop as they have not yet been bound to a value (the DO
loop, similar to LET, binds values in parallel).

After 10 iterations, the loop-step variable will have a value of
10. Accordingly, the end-test form will return T. When this occurs,
the result-forms are evaluated and the value of the last result form
is returned as the value of the loop.

In our example above, the value of square will be 81 at this point,
being the square of the last value of loop-step (9). This is the value
returned by the loop.

Note that the body-forms are not evaluated when the end-test is true,
and the last printed output is 64 in our example.

* The DO* Macro

The DO* macro is similar to a LET* form and binds its variables in
sequence. Therefore a variable can access the latest value of a
previously defined variable in either the initial or step forms. Below
is an near-identical example of the above, but with a DO* loop. The
DO* loop will return 100 and print 0, 1, 4, 9, 16, 25, 36, 48, 64 and
81 on newlines.

#+begin_src lisp

  (do* ((loop-step 0 (+ loop-step 1))
	(square loop-step (* loop-step loop-step)))
      ((= 10 loop-step) square) (print square))

#+end_src

As a final example, consider the below, where we switch the lexical
positions of loop-step and square within the loop. This example will
return 81 and print 0, 0, 1, 4, 9, 16, 25, 36, 49, 64 and 81. Observe
how square is now accessing the prior value of loop-step, as it is
evaluated before loop-step and does not have access to its current
value. This is a reminder that the DO* loop performs its bindings in
sequence.

#+begin_src lisp

  (do* ((square 0 (* loop-step loop-step))
	(loop-step 0 (+ loop-step 1)))
      ((= 10 loop-step) square) (print square))

#+end_src
