#+DATE: 24 July 2021

#+TITLE: Lists & List Manipulation

Previous: [[file:clbe-11.org][11. A Brief Detour - Code Formatting]]

Next: [[file:clbe-13.org][13. More on Functions]]

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

Lisp stands for List Processor and a deeper understanding of lists is
essential to proficiency in the language. Our earlier definition of
atoms & lists focused on their printed representation. We begin this
section with detail on their internal representation.

Inside computer memory, lists are organized as chains of cons
cells. CONS are a pair of pointers, the first cell is called the CAR
and the second the CDR. The CAR points to some data structure (e.g. an
integer, string, or even another list), while the CDR points to either
another CONS or to the empty list NIL.

Lists are thus defined recursively to be either empty lists or CONS
whose CDR components are lists. The list (A B C) is comprised of the
following (observe the recursive definition in action):

- *Recursive definition of the list (A B C)*: A cons with car of A and cdr
    of (B C) → A cons with car of B and cdr of (C) → A cons with car of C
    and cdr of NIL → The empty list NIL

Atoms are defined simply as not cons. The empty list NIL is both an
atom and a list. We can access the first and second con cells of a
list with the CAR and CDR accessors:

#+begin_src lisp

  ;; Returns 1

  (car '(1 2 3))

  ;; Returns (2 3)

  (cdr '(1 2 3))

#+end_src

We can join atoms or lists into a pair of cons cells with the CONS
function:

#+begin_src lisp

  ;; Returns (1 2 3)

  (cons 1 '(2 3))

  ;; Returns ((1 4) 2 3))

  (cons '(1 4) '(2 3))

#+end_src

Note in our last example, the CAR of the generated list is yet another
list (1 4) as we passed a list as the CAR argument of the CONS
function. This gives a glimpse into creating nested lists.

When printing a list in parenthesis notation, Lisp starts by printing
a left parenthesis followed by all the elements, separated by
spaces. If the list ends in NIL, Lisp prints a right parenthesis. A
proper list is a cons cell chain ending in NIL.

If the list does not end in NIL, before printing the right parenthesis
Lisp prints a space, a period, another space, and the atom that ends
the chain. A list not ending in NIL is called a dotted list:

#+begin_src lisp

  ;; Returns (1 . 2)
  
  (cons 1 2)

#+end_src

* Building & Copying Lists

The LIST function allows us to create lists of more than two elements
by consing onto NIL. The COPY-LIST function takes a list as its
argument and returns a copy of it. The APPEND function returns a
concatenation of the elements of any number of lists supplied as its
argument.

#+begin_src lisp

  ;; (3 A B C D)

  (list 3 'a 'b 'c 'd)


  ;; ((A B C D) 3)
  
  (list '(a b c d) 3)


  ;; (A B C D A B C D)
  
  (append '(a b c d)
	  '(a b c d))


  ;; (A B C D . 3)
  
  (append '(a b c d)
	  3) 

#+end_src

* Accessing List Elements

The NTH function can access an element at a given position in a list
while the function NTHCDR is used to get CDR at a given position. In
addition, we can FIRST - TENTH to get the 1st to 10th elements of a
list, while LAST will give the last CDR in a cons cell.

#+begin_src lisp

  ;; Returns A

  (first '(a b c d e f g))


  ;; Returns E
  
  (fifth '(a b c d e f g))

  
  ;; Returns 11
    
  (tenth '(1 2 3 4 5 6 7 8 9 11))


  ;; Returns (G) (the last CDR)
    
  (last '(a b c d e f g)) 

#+end_src

Finally, lists are sequences and there are a number of useful
functions for sequences that can be used on lists (these are discussed
later in this guide).

* Lists as Sets

Lists are a good way to represent small sets. The function MEMBER
checks if an element is part of a list and returns the part of the
list beginning with the element if it is found.

#+begin_src lisp

  ;; Returns (B C)
  
  (member 'b '(a b c))

#+end_src

Recall that lists are not unique and lists with the same elements can
be stored in different parts of computer memory. MEMBER utilises EQL
for its comparison, and will not return a match where the two lists
are stored in different parts of memory. To achieve this, i.e. to
compare lists on an element by element basis, utilise the following
configuration of the MEMBER function:

#+begin_src lisp

  ;; Element-wise test

  (member 'b '(a b c) :test #'equal) 

#+end_src

We can also specify a function to be applied to each element before
the comparison. In the below example, we test if there is an element
whose CAR is the symbol B:

#+begin_src lisp

  ;; Returns ((B) (C D))
  
  (member 'b '((a) (b) (c d)) :key #'car)

#+end_src

MEMBER-IF allows us to search for an element satisfying an arbitrary
predicate. For example, in the below, we search for odd numbers in the
list and return the part beginning with the first odd:

#+begin_src lisp

  ;; Returns (3 4)
  
  (member-if #'oddp '(2 3 4)) 

#+end_src

ADJOIN joins an object onto a list only if it is not already a member:

#+begin_src lisp

  ;; Returns (A B C)
  
  (adjoin 'b '(a b c))

  ;; Returns (Z A B C)

  (adjoin 'z '(a b c)) 
#+end_src

The below examples illustrate set union, intersection and complement
operations on exactly two lists. SET-DIFFERENCE returns a list of
elements of the first list that do not appear in the second list. Also
note that since there is no notion of ordering in a set, the below
functions do not necessarily bother to preserve the order of elements
found in the original list.

#+begin_src lisp

  ;; Returns (A B C S)
  
  (union '(a b c)
	 '(c b s))


  ;; Returns (C B)

  (intersection '(a b c)
		'(c b s))

  ;; Returns (A)
  
  (set-difference '(a b c) '(c b s))

#+end_src

* Association Lists

We can use a list of conses (remember a cons consists of two elements,
its car and its cdr) to represent mappings. ASSOC is used to retrieve
the value associated with a particular key. Below is an example of
defining and retrieving from an assoc-list (which is just a list of
conses):

#+begin_src lisp

  (defparameter mapping-table '((+ . "add") (- . "subtract")))


  ;; Returns (+ . "add")

  (assoc '+ mapping-table) 

#+end_src

* Pushdown Stacks

We can use lists as pushdown stacks. The macro PUSH can be used to
push an element to the front of the list, while the macro POP can
remove and return the first element of the list. Both are destructive
operations as they directly change the original lists in question. For
example:

#+begin_src lisp

  (defparameter my-list '(2 3 4))

  ;; Returns (1 2 3 4)

  (push 1 my-list)

  ;; Returns (1 2 3 4)

  my-list

  ;; Returns 1, the car of the list my-list

  (pop my-list)

  ;; Returns (2 3 4)

  my-list

#+end_src
