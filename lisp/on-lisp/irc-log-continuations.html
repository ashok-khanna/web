<!DOCTYPE html>
<html lang="en">
<head>
<!-- 2021-09-02 Thu 20:33 -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>&lrm;</title>
<meta name="generator" content="Org mode">
<meta name="author" content="Ashok Khanna">
 <meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="stylesheet" type="text/css" href="/css/style.css" />
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2020 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href="index.html"> UP </a>
 |
 <a accesskey="H" href="https://www.akhanna.net"> HOME </a>
</div><div id="preamble" class="status">
<div id="logo"><a href="https://www.akhanna.net"Ashok Khanna</a></div>
</div>
<div id="content">
<p>
Can the condition system replicate continuations?
16:22:26
phoe
no
16:22:50
phoe
continuations require the ability to store away control stacks, whereas the condition system works on a single control stack.
16:23:19
lisp123_
Thanks - I was wondering if it was possible with some sort of nesting structure
16:23:20
phoe
when an unwind is performed, whether by the condition system or by some other means, the stack is destroyed
16:23:31
phoe
you can't work around that without support from the language runtime
16:23:34
lisp123_
Got it, thanks
16:24:11
phoe
gotta go lower level than conditions if you want to get support for that
16:25:18
lisp123_
Yeah I was able to do it via PG's Continuation Macros (which I'm debugging now, not sure if I made a mistake somewhere), but was something that just popped in my mind because he was using the function RESTART, which means he did it before the condition system entered CL
16:26:06
pjb
akater[m]: that's because TRUENAME must do the same as OPEN, and OPEN must call MERGE-PATHNAMES on relative pathnames. "For information about opening relative pathnames, see Section 19.2.3 (Merging Pathnames)."
16:26:27
lotuseater
lisp123_: but the other way around could be possible ^^ Continuations, the mother of all monads :D
16:26:53
lisp123_
lotuseater: And GOTO the mother of all expressions :D
16:27:08
Bike
restarts only have dynamic extent, so you couldn't use them for full call/cc
16:27:26
lisp123_
<a href="https://dspace.mit.edu/bitstream/handle/1721.1/5753/AIM-443.pdf">https://dspace.mit.edu/bitstream/handle/1721.1/5753/AIM-443.pdf</a>
16:27:28
lotuseater
I thought it was: Lambda, The ultimate GOTO.
16:27:31
lisp123_
Good article for anyone interested
16:27:41
lotuseater
nice thx
16:27:44
lisp123_
lol I just linked the same article
16:28:19
lotuseater
wish me luck, later I have the first phone call with the customer for the new project
16:28:44
lisp123_
(append 'luck lotuseaster)
16:28:59
lotuseater
hah lisp123_ we had the same thought. there are also this paper with Imperative/Declarative
16:29:13
lotuseater
hm would that work?
16:29:34
pjb
(let ((lotuseaster '())) (append 'luck lotuseaster)) #| ERROR: The value luck is not of the expected type list. |#   (let ((lotuseaster '())) (append lotuseaster  'luck)) #| &#x2013;&gt; luck |#
16:30:14
lotuseater
or (setf (person-lucky-p <b>lotuseater</b>) t) or an amount between 0 and 1 but bigger than 0
16:31:26
lotuseater
i should drink some water
16:31:59
pjb
lisp123_: we can implement delimited continuations in CL easily enough. But full contiuations need a lot of machinery (basically a re-compilation of the CL code).
16:32:31
pjb
lisp123_: cf <a href="https://www.cliki.net/continuations">https://www.cliki.net/continuations</a>
16:32:37
lisp123_
pjb: what does it mean by "delimited continuations"? Is that the same as PG's restriction that every continuation should be nested?
16:32:42
lisp123_
in a tail call
16:32:42
pjb
lisp123_: compare arnesi vs cl-cont
16:33:24
pjb
It's continations that don't escape their lexical scope.
16:33:34
Bike
<a href="https://en.wikipedia.org/wiki/Delimited_continuation">https://en.wikipedia.org/wiki/Delimited_continuation</a>
16:33:39
pjb
So the processor doesn't have to jump back to unstacked stack frames.
16:33:50
pjb
Ie. we don't have to copy stack frames to the heap.
16:34:06
lisp123_
Thanks, that makes sense (and what was noted in On Lisp too)
16:34:28
lotuseater
when I told someone it's kind of runtime GOTO he just heard "GOTO" and said "no that shouldn't be used"
16:35:10
beach
That's what Turbo thought about Pascal, so they removed the only exception mechanism that Pascal had.
16:35:32
Bike
delimited continuations as used in other languages are orthogonal to lexical extent
16:35:48
Bike
you can see this in the wikipedia article in the definition of "yield" a ways down
16:35:59
lisp123_
Bike: that is a very nice and clear way to put it
16:36:06
lotuseater
ACTION presses the "Turbo" button at his computer
16:37:34
Bike
you might also have to copy frames to the heap to implement them, since the delimited continuation still has indefinite extent, which you can see in "stream-yield" where the continuation is stored in a lazy list
16:39:00
lisp123_
Yes (i think, haven't look at "stream-yield" yet)
16:39:35
Bike
i don't remember how well CPS transform macros fit into this off the top of my head
16:40:04
lisp123_
They seem to work well for most cases
16:40:25
Bike
i just mean i don't remember whether they're theoretically equivalent to some kind of delimited continuation or what
16:41:09
lisp123_
Based on what I saw, I say they are, but there might be some points I missed, I'm only looking at the two at a superficial level
16:41:35
lisp123_
"If an =bind, =values, =apply, or =funcall expression occurs in a seg- ment of code, it must be a tail call. Any code to be evaluated after an =bind should be put in its body."
16:42:03
lisp123_
vs. "So the processor doesn't have to jump back to unstacked stack frames."
16:42:12
lisp123_
Sounds about the same
16:42:33
Bike
okay, but as i mentioned, that's not actually an accurate description of delimited continuations
16:42:45
Bike
that's just a continuation with dynamic extent, which we already have with block/return-from
16:42:53
White<sub>Flame</sub>
yeah, I've made the same linguistic mistake before
16:43:24
Bike
and i think CPS macros give you more than that
16:44:20
lisp123_
Nice, I will have to read into it more
16:46:19
Bike
block/return-from are undelimited continuations, i guess, since they abort control, unlike a delimited continuation
16:46:28
Bike
some confusing language here to be sure
16:47:01
lisp123_
Yup and with material consequences for not being exact, given their use in estoeric code
17:00:12
phoe
Bike: hmmm
17:00:37
phoe
just thinking about "what if restarts weren't DX"
17:00:56
phoe
you would still need to be able to encode the rest of the computation in some way, which still requires a CPS transform
17:01:24
Bike
yeah, probably.
17:04:24
Bike
restarts are just a dynamic namespace for functions. don't actually do any control transfer stuff themselves. i forgot.
17:05:35
phoe
it's easy to define a non-DX restart equivalent, everything control-flow-related is still up to THROW and RETURN-FROM and GO though
17:05:47
phoe
and you need to somehow defeat these in order to preserve stacks for CPS
17:21:13
pjb
Bike: the argument is that they are not because: (let ((c (block cont (lambda (x) (return-from cont x))))) (list (funcall c 42) (funcall c 33))) does not work.
17:21:59
shka
i am having problem with azure postgres server and postmodern
17:22:21
shka
azure postgres uses special format of the user
17:22:25
shka
user@host
17:22:38
shka
and i think that this causes in postmodern
17:22:58
pjb
If postmodern parses user strings, it's possible. A patch would be in order.
17:37:58
shka
i will investigate
17:39:22
Bike
pjb: they are not what? undelimited? "undelimited" does not mean "indefinite extent". i know blocks don't have indefinite extent and i said as much
18:13:51
lisp123__
I'm getting a strange error, but I'm not sure if anyone can point me in the right direction as its obscure
18:14:01
phoe
what is the error
18:14:24
lisp123__
It is "RESTART1 is a macro, not a function" when I am calling the macro RESTART1
18:14:34
phoe
how are you calling the macro RESTART1?
18:14:39
phoe
and is that Common Lisp?
18:14:44
lisp123__
CL yes
18:14:57
lisp123__
(cond ((null tree) (print "yo") (restart1))
18:15:10
phoe
hmmmmmm
18:15:12
lisp123__
so the error happens when tree is null and restart1 is called
18:15:17
lisp123__
but it works for all other nodes
18:15:23
phoe
I need more context, please post your code at <a href="https://plaster.tymoon.eu/">https://plaster.tymoon.eu/</a>
18:15:28
phoe
what is your implementation and version?
18:17:41
lisp123__
SBCL
18:17:42
lisp123__
<a href="https://plaster.tymoon.eu/view/2579#2579">https://plaster.tymoon.eu/view/2579#2579</a>
18:18:16
lisp123__
Its pretty convoluted so I wouldn't bother too much, it will take me some time to figure out&#x2026;
18:19:14
Guest87
</p>
<div id="outline-container-org9d49a11" class="outline-2">
<h2 id="org9d49a11">NICK icer</h2>
<div class="outline-text-2" id="text-org9d49a11">
<p>
18:20:59
phoe
please read the compilation warnings
18:21:23
phoe
there are some heavy warnings all over the place coming from the two =DEFUN forms
18:21:35
phoe
I'm not touching that code until it compiles cleanly
18:22:05
lisp123__
no worries, its a bit obscure I know
18:22:35
phoe
obscure or not, if it doesn't compile without warnings then it very likely won't work
18:22:55
Bike
you need (defvar <b>cont</b>) (defvar <b>saved</b>) in there somewhere
18:23:14
Bike
also, this doesn't have a definition of dft-node, so we can't run it.
18:23:17
phoe
"undefined function: COMMON-LISP-USER::DFT-NODE" also looks like it needs some attention
18:24:09
Bike
(defvar <b>cont</b> #'identity), actually. PG has (setq <b>cont</b> #'identity) in his book, which is incorrect.
18:24:25
lisp123__
Bike: Sorry, added in: <a href="https://plaster.tymoon.eu/view/2579#2579">https://plaster.tymoon.eu/view/2579#2579</a>
18:25:26
lisp123__
This is a related version: <a href="https://stackoverflow.com/questions/24721676/continuation-in-common-lisp-by-macros-regarding-an-implemetation-in-onlisp">https://stackoverflow.com/questions/24721676/continuation-in-common-lisp-by-macros-regarding-an-implemetation-in-onlisp</a>
18:25:46
lisp123__
Currently my code is 1:1 from the On Lisp
18:26:32
lisp123__
Most of it works, except for when trying to work with the very last function
18:26:40
lisp123__
expression*
18:27:37
Bike
Okay. I fixed all the problems and ran that expression, and then I did (restart1) repeatedly. It returned a bunch of different values and then DONE, so I think it's working.
18:28:08
lisp123__
What was the problem?
18:28:15
Bike
If you're seeing something different you might just need to recompile it. =defun will define RESTART1 as a macro rather than a function, as PG explains in his book, so you might have an out of date definition of it.
18:28:33
Bike
The problems were mostly that PG keeps doing (setq something value) instead of (defvar something value)
18:28:49
Bike
if you want to use a top level variable you actually have to define one
18:29:00
lisp123__
I loaded the functions with C-x C-e - that wouldn't have been the source of the issues by any chance (you mentioned 'recompile')?
18:29:23
Bike
I don't think evaluating rather than compiling would matter, but let me check
18:29:53
Bike
er, hang on
18:29:58
Bike
you mean you did C-x C-e one by one on each form?
18:30:02
lisp123__
Yes
18:30:20
phoe
in which order?
18:30:29
phoe
I usually use C-x C-k for whole-file compilation
18:30:29
Bike
just do C-c C-l to load the whole file at once
18:30:33
lisp123__
Just down the page
18:31:10
Bike
oh hey, evaluating it did result in the error. let me see
18:31:20
lisp123__
yyup - sometimes it does, sometimes it doesn't
18:31:29
Bike
I see the problem.
18:31:46
Bike
=defun defines restart1 as a macro, as mentioned. However, you have restart1 defined after dft-node, which has a (restart1) form.
18:32:07
Bike
So if you load the file sequentially, the macroexpansion of dft-node's body will assume that restart1 is a function, and rewrite it as a CPS call.
18:32:37
Bike
which doesn't work obviously.
18:32:58
lisp123__
Yay! It works
18:33:02
lisp123__
:) Thanks!!!!!
18:33:15
lisp123__
Now I know why it worked sometime and not, I must have evaluated restart1 first in those caes
18:33:44
Bike
no problem. in the future you might want to default to using slime-compile-and-load-file, C-c C-k in slime
18:34:12
lisp123__
You guys are too smart, that was pretty obscure!
18:34:28
Bike
although really the good fix is to define restart1 first. i wonder why PG didn't
18:35:08
lisp123__
Yeah he had it in the wrong order too
18:35:40
lisp123__
It worked for the simple cases, but fell over in the more advanced one that I was having at the end of the file
18:36:05
lisp123__
Does order not matter if one uses C-c C-k?
18:38:31
lisp123__
Also (as a final), is this how you avoided the undefined variables "trick" that PG did? <a href="https://plaster.tymoon.eu/view/2580#2580">https://plaster.tymoon.eu/view/2580#2580</a>
18:39:31
Bike
i just did (defvar <b>cont</b> #'identity)
18:39:54
Bike
i think PG meant it to be dynamically scoped
18:40:15
Bike
that's usually what <b>earmuffs</b> mean
18:40:41
lisp123__
No he wanted it to not be special
18:40:56
Bike
where does it say that?
18:41:00
lisp123__
That's why he didn't define it, because he wanted <b>cont</b> within the macros to shadow the outer <b>cont</b>
18:41:23
lisp123__
It is by manipulating <b>cont</b> that we will get the effect of continuations. Although <b>cont</b> has a global value, this will rarely be the one used: <b>cont</b> will nearly always be a parameter, captured by =values and the macros defined by =defun. Within the body of add1, for example, <b>cont</b> is a parameter and not the global variable. This distinction is important because these macros wouldn’t work if <b>cont</b> were not a local variable. That’
18:41:24
lisp123__
s why <b>cont</b> is given its initial value in a setq instead of a defvar: the latter would also proclaim it to be special.
18:41:46
Bike
okay, well, that's kind of perverse
18:41:52
phoe
right?
18:42:01
Bike
do not follow PG's example here
18:42:09
phoe
a defglobal would not work here because it doesn't allow shadowing
18:42:15
phoe
a symbol macro would kind of work
18:42:15
lisp123__
This was the suggested approach on SO <a href="https://plaster.tymoon.eu/view/2580#2580">https://plaster.tymoon.eu/view/2580#2580</a>
18:42:39
phoe
yes, except the symbols are mismatched
18:42:44
phoe
actual-cont versus <b>actual-cont</b>
18:42:46
lisp123__
Does that work to create global lexically scoped variables?
18:43:00
phoe
it <b>emulates</b> global lexically scoped variables that can also be shadowed
18:43:07
phoe
standard CL has no way of creating those
18:43:40
lisp123__
Thanks! And this is 'portable' code?
18:44:02
phoe
yes, it should work on all conforming implementations
18:44:24
lisp123__
Cool :)
Tuesday, 3rd of Augus
</p>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="Date">Last updated: </p><script src="/scripts/main.js"></script>
</div>
</body>
</html>
