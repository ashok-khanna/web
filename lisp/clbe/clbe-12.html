<!DOCTYPE html>
<html lang="en">
<head>
<!-- 2021-09-05 Sun 00:49 -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Lists &amp; List Manipulation</title>
<meta name="generator" content="Org mode">
<meta name="author" content="Ashok Khanna">
 <meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="stylesheet" type="text/css" href="/css/style.css" />
</head>
<body>
<div id="preamble" class="status">
<div id="quote">Ashok Khanna</div>
<div id="home-link"><a href="/index.html">Home</a></div>
<div id="articles-link"><a href="/articles.html">Articles</a></div>
<div id="resources-link"><a href="/resources.html">Resources</a></div>
</div>
<div id="content">
<h1 class="title">Lists &amp; List Manipulation</h1>
<p>
Previous: <a href="clbe-11.html">11. A Brief Detour - Code Formatting</a>
</p>

<p>
Next: <a href="clbe-13.html">13. More on Functions</a>
</p>

<p>
Lisp stands for List Processor and a deeper understanding of lists is
essential to proficiency in the language. Our earlier definition of
atoms &amp; lists focused on their printed representation. We begin this
section with detail on their internal representation.
</p>

<p>
Inside computer memory, lists are organized as chains of cons
cells. CONS are a pair of pointers, the first cell is called the CAR
and the second the CDR. The CAR points to some data structure (e.g. an
integer, string, or even another list), while the CDR points to either
another CONS or to the empty list NIL.
</p>

<p>
Lists are thus defined recursively to be either empty lists or CONS
whose CDR components are lists. The list (A B C) is comprised of the
following (observe the recursive definition in action):
</p>

<ul class="org-ul">
<li><b>Recursive definition of the list (A B C)</b>: A cons with car of A and cdr
of (B C) → A cons with car of B and cdr of (C) → A cons with car of C
and cdr of NIL → The empty list NIL</li>
</ul>

<p>
Atoms are defined simply as not cons. The empty list NIL is both an
atom and a list. We can access the first and second con cells of a
list with the CAR and CDR accessors:
</p>

<div class="org-src-container">
<pre class="src src-lisp">
<span style="color: #b22222;">;; </span><span style="color: #b22222;">Returns 1</span>

(car '(1 2 3))

<span style="color: #b22222;">;; </span><span style="color: #b22222;">Returns (2 3)</span>

(cdr '(1 2 3))

</pre>
</div>

<p>
We can join atoms or lists into a pair of cons cells with the CONS
function:
</p>

<div class="org-src-container">
<pre class="src src-lisp">
<span style="color: #b22222;">;; </span><span style="color: #b22222;">Returns (1 2 3)</span>

(cons 1 '(2 3))

<span style="color: #b22222;">;; </span><span style="color: #b22222;">Returns ((1 4) 2 3))</span>

(cons '(1 4) '(2 3))

</pre>
</div>

<p>
Note in our last example, the CAR of the generated list is yet another
list (1 4) as we passed a list as the CAR argument of the CONS
function. This gives a glimpse into creating nested lists.
</p>

<p>
When printing a list in parenthesis notation, Lisp starts by printing
a left parenthesis followed by all the elements, separated by
spaces. If the list ends in NIL, Lisp prints a right parenthesis. A
proper list is a cons cell chain ending in NIL.
</p>

<p>
If the list does not end in NIL, before printing the right parenthesis
Lisp prints a space, a period, another space, and the atom that ends
the chain. A list not ending in NIL is called a dotted list:
</p>

<div class="org-src-container">
<pre class="src src-lisp">
<span style="color: #b22222;">;; </span><span style="color: #b22222;">Returns (1 . 2)</span>

(cons 1 2)

</pre>
</div>

<div id="outline-container-org9fd0305" class="outline-2">
<h2 id="org9fd0305">Building &amp; Copying Lists</h2>
<div class="outline-text-2" id="text-org9fd0305">
<p>
The LIST function allows us to create lists of more than two elements
by consing onto NIL. The COPY-LIST function takes a list as its
argument and returns a copy of it. The APPEND function returns a
concatenation of the elements of any number of lists supplied as its
argument.
</p>

<div class="org-src-container">
<pre class="src src-lisp">
<span style="color: #b22222;">;; </span><span style="color: #b22222;">(3 A B C D)</span>

(list 3 'a 'b 'c 'd)


<span style="color: #b22222;">;; </span><span style="color: #b22222;">((A B C D) 3)</span>

(list '(a b c d) 3)


<span style="color: #b22222;">;; </span><span style="color: #b22222;">(A B C D A B C D)</span>

(append '(a b c d)
        '(a b c d))


<span style="color: #b22222;">;; </span><span style="color: #b22222;">(A B C D . 3)</span>

(append '(a b c d)
        3) 

</pre>
</div>
</div>
</div>

<div id="outline-container-org0921a3e" class="outline-2">
<h2 id="org0921a3e">Accessing List Elements</h2>
<div class="outline-text-2" id="text-org0921a3e">
<p>
The NTH function can access an element at a given position in a list
while the function NTHCDR is used to get CDR at a given position. In
addition, we can FIRST - TENTH to get the 1st to 10th elements of a
list, while LAST will give the last CDR in a cons cell.
</p>

<div class="org-src-container">
<pre class="src src-lisp">
<span style="color: #b22222;">;; </span><span style="color: #b22222;">Returns A</span>

(first '(a b c d e f g))


<span style="color: #b22222;">;; </span><span style="color: #b22222;">Returns E</span>

(fifth '(a b c d e f g))


<span style="color: #b22222;">;; </span><span style="color: #b22222;">Returns 11</span>

(tenth '(1 2 3 4 5 6 7 8 9 11))


<span style="color: #b22222;">;; </span><span style="color: #b22222;">Returns (G) (the last CDR)</span>

(last '(a b c d e f g)) 

</pre>
</div>

<p>
Finally, lists are sequences and there are a number of useful
functions for sequences that can be used on lists (these are discussed
later in this guide).
</p>
</div>
</div>

<div id="outline-container-org6f6956a" class="outline-2">
<h2 id="org6f6956a">Lists as Sets</h2>
<div class="outline-text-2" id="text-org6f6956a">
<p>
Lists are a good way to represent small sets. The function MEMBER
checks if an element is part of a list and returns the part of the
list beginning with the element if it is found.
</p>

<div class="org-src-container">
<pre class="src src-lisp">
<span style="color: #b22222;">;; </span><span style="color: #b22222;">Returns (B C)</span>

(member 'b '(a b c))

</pre>
</div>

<p>
Recall that lists are not unique and lists with the same elements can
be stored in different parts of computer memory. MEMBER utilises EQL
for its comparison, and will not return a match where the two lists
are stored in different parts of memory. To achieve this, i.e. to
compare lists on an element by element basis, utilise the following
configuration of the MEMBER function:
</p>

<div class="org-src-container">
<pre class="src src-lisp">
<span style="color: #b22222;">;; </span><span style="color: #b22222;">Element-wise test</span>

(member 'b '(a b c) <span style="color: #483d8b;">:test</span> #'equal) 

</pre>
</div>

<p>
We can also specify a function to be applied to each element before
the comparison. In the below example, we test if there is an element
whose CAR is the symbol B:
</p>

<div class="org-src-container">
<pre class="src src-lisp">
<span style="color: #b22222;">;; </span><span style="color: #b22222;">Returns ((B) (C D))</span>

(member 'b '((a) (b) (c d)) <span style="color: #483d8b;">:key</span> #'car)

</pre>
</div>

<p>
MEMBER-IF allows us to search for an element satisfying an arbitrary
predicate. For example, in the below, we search for odd numbers in the
list and return the part beginning with the first odd:
</p>

<div class="org-src-container">
<pre class="src src-lisp">
<span style="color: #b22222;">;; </span><span style="color: #b22222;">Returns (3 4)</span>

(member-if #'oddp '(2 3 4)) 

</pre>
</div>

<p>
ADJOIN joins an object onto a list only if it is not already a member:
</p>

<div class="org-src-container">
<pre class="src src-lisp">
<span style="color: #b22222;">;; </span><span style="color: #b22222;">Returns (A B C)</span>

(adjoin 'b '(a b c))

<span style="color: #b22222;">;; </span><span style="color: #b22222;">Returns (Z A B C)</span>

(adjoin 'z '(a b c)) 
</pre>
</div>

<p>
The below examples illustrate set union, intersection and complement
operations on exactly two lists. SET-DIFFERENCE returns a list of
elements of the first list that do not appear in the second list. Also
note that since there is no notion of ordering in a set, the below
functions do not necessarily bother to preserve the order of elements
found in the original list.
</p>

<div class="org-src-container">
<pre class="src src-lisp">
<span style="color: #b22222;">;; </span><span style="color: #b22222;">Returns (A B C S)</span>

(union '(a b c)
       '(c b s))


<span style="color: #b22222;">;; </span><span style="color: #b22222;">Returns (C B)</span>

(intersection '(a b c)
              '(c b s))

<span style="color: #b22222;">;; </span><span style="color: #b22222;">Returns (A)</span>

(set-difference '(a b c) '(c b s))

</pre>
</div>
</div>
</div>

<div id="outline-container-org674ba8f" class="outline-2">
<h2 id="org674ba8f">Association Lists</h2>
<div class="outline-text-2" id="text-org674ba8f">
<p>
We can use a list of conses (remember a cons consists of two elements,
its car and its cdr) to represent mappings. ASSOC is used to retrieve
the value associated with a particular key. Below is an example of
defining and retrieving from an assoc-list (which is just a list of
conses):
</p>

<div class="org-src-container">
<pre class="src src-lisp">
(<span style="color: #a020f0;">defparameter</span> <span style="color: #a0522d;">mapping-table</span> '((+ . <span style="color: #8b2252;">"add"</span>) (- . <span style="color: #8b2252;">"subtract"</span>)))


<span style="color: #b22222;">;; </span><span style="color: #b22222;">Returns (+ . "add")</span>

(assoc '+ mapping-table) 

</pre>
</div>
</div>
</div>

<div id="outline-container-org9f0c587" class="outline-2">
<h2 id="org9f0c587">Pushdown Stacks</h2>
<div class="outline-text-2" id="text-org9f0c587">
<p>
We can use lists as pushdown stacks. The macro PUSH can be used to
push an element to the front of the list, while the macro POP can
remove and return the first element of the list. Both are destructive
operations as they directly change the original lists in question. For
example:
</p>

<div class="org-src-container">
<pre class="src src-lisp">
(<span style="color: #a020f0;">defparameter</span> <span style="color: #a0522d;">my-list</span> '(2 3 4))

<span style="color: #b22222;">;; </span><span style="color: #b22222;">Returns (1 2 3 4)</span>

(push 1 my-list)

<span style="color: #b22222;">;; </span><span style="color: #b22222;">Returns (1 2 3 4)</span>

my-list

<span style="color: #b22222;">;; </span><span style="color: #b22222;">Returns 1, the car of the list my-list</span>

(pop my-list)

<span style="color: #b22222;">;; </span><span style="color: #b22222;">Returns (2 3 4)</span>

my-list

</pre>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="Date">Last updated: 24 July 2021</p><script src="/scripts/main.js"></script>
</div>
</body>
</html>
