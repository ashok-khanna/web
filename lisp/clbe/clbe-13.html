<!DOCTYPE html>
<html lang="en">
<head>
<!-- 2021-09-06 Mon 00:50 -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>More on Functions</title>
<meta name="generator" content="Org mode">
<meta name="author" content="Ashok Khanna">
 <meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="stylesheet" type="text/css" href="/css/style.css" />
</head>
<body>
<div id="preamble" class="status">
<div id="quote">Ashok Khanna</div>
<div id="home-link"><a href="/index.html">Home</a></div>
<div id="articles-link"><a href="/articles.html">Articles</a></div>
<div id="resources-link"><a href="/resources.html">Resources</a></div>
</div>
<div id="content">
<h1 class="title">More on Functions</h1>
<p>
Previous: <a href="clbe-12.html">12. Lists &amp; List Manipulation</a>
</p>

<p>
Next: <a href="clbe-14.html">14. Arrays &amp; Sequences</a>
</p>

<p>
Functions in Lisp are first-class objects that generally support all
operations available to other data objects, such as being modified,
passed as an argument, returned from a function and being assigned to
a variable.
</p>

<p>
The FUNCTION special operator (shorthand #') returns the function
object associated with the name of function that is supplied as an
argument:
</p>

<div class="org-src-container">
<pre class="src src-lisp">
<span style="color: #b22222;">;; </span><span style="color: #b22222;">Returns the function object</span>

(function +)

<span style="color: #b22222;">;; </span><span style="color: #b22222;">Equivalent syntax</span>

#'+

</pre>
</div>

<p>
When you type the above in your toplevel, your Lisp implementation
will print the external representation of the function object
(implementations are free to choose whatever external representation
they like), such as #&lt;FUNCTION +&gt;. Internally however, a built-in
function like + is likely to be a segment of machine language. CONS or
</p>
<ul class="org-ul">
<li>are examples of symbols used to name built-in Lisp functions. The</li>
</ul>
<p>
symbol CONS has a pointer in its function cell to a "compiled code
object" that represents the machine language instructions for creating
new cons cells.
</p>

<p>
For user defined functions, the DEFUN macro is used to name a function
with a symbol. For example, in the below example, the symbol HALF
names the function, whilst the symbol itself is named by the string
"HALF". The function cell of the symbol points to a function object
that is the real function. Exactly what this function object looks
like depends on which implementation of Common Lisp you’re using, but
as the diagram indicates, there’s probably a lambda expression in
there somewhere.
</p>

<p>
APPLY takes a function and a list of arguments for it and returns the
result of applying the function to its arguments. Note how we have to
use to sharp-quote (#') to pass the + function as an object into the
APPLY function. Without doing so, Lisp will return an error as it will
try to evaluate +, which is not legally permissible in the below
example.
</p>

<div class="org-src-container">
<pre class="src src-lisp">
<span style="color: #b22222;">;; </span><span style="color: #b22222;">Returns 6</span>

(apply #'+ '(1 2 3)) 

</pre>
</div>

<p>
The function FUNCALL is similar to APPLY, but allows us to pass
arguments individually and not packaged as a list:
</p>

<div class="org-src-container">
<pre class="src src-lisp">
<span style="color: #b22222;">;; </span><span style="color: #b22222;">Returns 6</span>

(funcall #'+ 1 2 3)

</pre>
</div>

<p>
We can use APPLY and FUNCALL to evaluate lambda expressions, as lambda
expressions are nothing but lists which can be used directly in place
of function names.
</p>

<p>
Below is an example of passing a lambda expression to FUNCALL:
</p>

<div class="org-src-container">
<pre class="src src-lisp">
<span style="color: #b22222;">;; </span><span style="color: #b22222;">Returns 6</span>

(funcall #'(<span style="color: #a020f0;">lambda</span> (x y z)
             (+ x y z))
         1 2 3)

</pre>
</div>

<p>
As a closing remark, Lisp programs are nothing but lists
themselves. The function EVAL takes an expression, evaluates it and
returns its value. In fact, our toplevel is nothing but a
read-eval-print loop (hence known as REPL). Calling EVAL ourselves is
not advisable as it is inefficient (lists are evaluated at run-time
and not as compiled coded) and as it does not handle lexical context
(EVAL within a LET cannot refer to variables established by the
LET). Indeed, one of the only places where it is appropriate to use
EVAL is in a top-level loop.
</p>

<div class="org-src-container">
<pre class="src src-lisp">
<span style="color: #b22222;">;; </span><span style="color: #b22222;">Returns 6</span>

(eval '(+ 1 2 3))

</pre>
</div>

<div id="outline-container-org50e5601" class="outline-2">
<h2 id="org50e5601">Function Parameters</h2>
<div class="outline-text-2" id="text-org50e5601">
<p>
By default, a function call must supply values for all parameters that
feature in the function definition. We can modify this behaviour with
the &amp;optional, &amp;key and &amp;rest tokens. The &amp;optional token allows to
distinguish between required parameters, placed before the &amp;optional
token, and optional parameters, placed after the token:
</p>

<div class="org-src-container">
<pre class="src src-lisp">
(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">make-a-list</span> (a b c d <span style="color: #228b22;">&amp;optional</span> e f g)
  (list a b c d e f g))


<span style="color: #b22222;">;; </span><span style="color: #b22222;">Returns (1 2 3 4 5 NIL NIL)</span>

(make-a-list 1 2 3 4 5)

</pre>
</div>

<p>
One drawback of the &amp;optional token, using the above as an example, is
that we need to supply values for E and F if we want to supply the
value for G, as arguments in a function call are assigned to the
parameters in order. To overcome this, we utilise the &amp;key token to be
able to specify which optional parameter we want to assign a value
to. Below is an example of this,
</p>

<div class="org-src-container">
<pre class="src src-lisp">
(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">make-a-list-2</span> (a b c d <span style="color: #228b22;">&amp;key</span> (e 1) f g)
  (list a b c d e f g))


<span style="color: #b22222;">;; </span><span style="color: #b22222;">Returns (1 2 3 4 1 NIL 7)</span>

(make-a-list-2 1 2 3 4 <span style="color: #483d8b;">:g</span> 7)

</pre>
</div>

<p>
The preceding example also shows how we can supply a default value to
an optional (setting E to 1 if no value for E is provided). When we
called this function in the above, we set G to 7 and E also defaulted
to 1. As no value was supplied for F, it defaulted to NIL.
</p>

<p>
In general, &amp;key is preferable to &amp;optional as it allows us to have
greater control in our function calls. It also makes code easier to
maintain and evolve as we can add new parameters to a function without
affecting existing function calls (useful when writing libraries that
are already being used by other programs).
</p>

<p>
Finally, the &amp;rest token, placed before the last variable in a
parameter list, allows us to write functions that can accept an
unknown number of arguments. The last variable will be set to a list
of all the remaining arguments supplied by the function call:
</p>

<div class="org-src-container">
<pre class="src src-lisp">
(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">make-a-list-3</span> (a b c d <span style="color: #228b22;">&amp;rest</span> e) (list a b c d e))

(make-a-list-3 1 2 3 4 5 6 7 8) <span style="color: #b22222;">; (1 2 3 4 (5 6 7 8))</span>

</pre>
</div>

<p>
We can utilise multiple tokens in the same function call, as long as
we declare them in order. First the names of required parameters are
declared, then the optional parameters, then the rest parameter and
finally the keyword parameters are declared.
</p>
</div>
</div>

<div id="outline-container-org641da64" class="outline-2">
<h2 id="org641da64">Multiple-Value-Binds</h2>
<div class="outline-text-2" id="text-org641da64">
<p>
Until now, we have only considered functions that return one value. In
certain circumstances it is useful for a function to return several
values, without having to build an overarching structure to contain
them all. This is achieved through multiple-value-binds.
</p>

<p>
The VALUES function returns multiple values and can be used as the
last expression in the body of a function. The below example returns
1, NIL and 6 (individually, not as a list):
</p>

<div class="org-src-container">
<pre class="src src-lisp">
(values 1 nil (+ 2 4))

</pre>
</div>

<p>
If a VALUES function is supplied as an argument to a form which is
only expecting one value, the first value returned by the VALUES
function is used and the rest are discarded:
</p>

<div class="org-src-container">
<pre class="src src-lisp">
<span style="color: #b22222;">;; </span><span style="color: #b22222;">Returns 6</span>

(+ 5 (values 1 nil (+ 2 4)))

</pre>
</div>

<p>
The MULTIPLE-VALUE-BIND macro is used to receive multiple values. The
first argument of this macro is the variables and the second is the
expression that returns their values. We can then use these values in
the body of the multiple-value-bind macro. Below is an example.
</p>

<div class="org-src-container">
<pre class="src src-lisp">
<span style="color: #b22222;">;; </span><span style="color: #b22222;">Returns (1 2 3)</span>

(<span style="color: #a020f0;">multiple-value-bind</span> (x y z) (values 1 2 3)
  (list x y z)) 

</pre>
</div>

<p>
If there are more variables than values, the leftover variables will
be bound to NIL. If there are more values than variables, the extra
values will be discarded. Finally, you can pass multiple values as
arguments to a function using the MULTIPLE-VALUE-CALL special
operator:
</p>

<div class="org-src-container">
<pre class="src src-lisp">
<span style="color: #b22222;">;; </span><span style="color: #b22222;">Returns 6</span>

(multiple-value-call #'+ (values 1 2 3)) 

</pre>
</div>
</div>
</div>

<div id="outline-container-org9ac3eb7" class="outline-2">
<h2 id="org9ac3eb7">Applying Functions To Elements of a List</h2>
<div class="outline-text-2" id="text-org9ac3eb7">
<p>
MAPCAR takes a function and one or more lists and returns a list of
the results of applying the function to elements taken from each
list. A function with multiple arguments takes one element from each
list, as in the second and third examples below.
</p>

<div class="org-src-container">
<pre class="src src-lisp">
<span style="color: #b22222;">;; </span><span style="color: #b22222;">Returns (2 3 4)</span>

(mapcar #'(<span style="color: #a020f0;">lambda</span> (x)
            (+ x 1))
        '(1 2 3))


<span style="color: #b22222;">;; </span><span style="color: #b22222;">Returns (6 12 18)</span>

(mapcar #'(<span style="color: #a020f0;">lambda</span> (x y)
            (+ x y))
        '(1 2 3)
        '(5 10 15))


<span style="color: #b22222;">;; </span><span style="color: #b22222;">Returns (16 32 48)</span>

(mapcar #'+ '(1 2 3)
        '(5 10 15)
        '(10 20 30))

</pre>
</div>

<p>
A similar function is MAPLIST, which works on successive cdrs of the
list:
</p>

<div class="org-src-container">
<pre class="src src-lisp">
<span style="color: #b22222;">;; </span><span style="color: #b22222;">Returns ((1 2 3) (2 3) (3))</span>

(maplist #'(<span style="color: #a020f0;">lambda</span> (x)
             x)
         '(1 2 3))

</pre>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="Date">Last updated: 24 July 2021</p><script src="/scripts/main.js"></script>
</div>
</body>
</html>
