<!DOCTYPE html>
<html lang="en">
<head>
<!-- 2021-09-06 Mon 01:59 -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Arrays &amp; Sequences</title>
<meta name="generator" content="Org mode">
<meta name="author" content="Ashok Khanna">
 <meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="stylesheet" type="text/css" href="/css/style.css" />
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script type="text/javascript"
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="preamble" class="status">
<div id="quote">Ashok Khanna</div>
<div id="home-link"><a href="/index.html">Home</a></div>
<div id="articles-link"><a href="/articles.html">Articles</a></div>
<div id="resources-link"><a href="/resources.html">Resources</a></div>
</div>
<div id="content">
<h1 class="title">Arrays &amp; Sequences</h1>
<p class="nav-links">
Previous: <a href="clbe-13.html" class="nav-links">13. More on Functions</a>
</p>
<p class="nav-links">
Next: <a href="clbe-15.html" class="nav-links">15. Hash Tables</a>
</p>


<div class="theorem">
<p>
If an integer \(n\) is greater than 2, then the equation \(a^n + b^n = c^n\)
has no solutions in non-zero integers \(a\), \(b\), and \(c\).
</p>

</div>

<p>
The function MAKE-ARRAY allows us to create arrays. For example, we
can create a 2 x 3 array as follows:
</p>

<div class="org-src-container">
<pre class="src src-lisp">
(<span style="color: #a020f0;">defparameter</span> <span style="color: #a0522d;">my-array</span>
  (make-array '(2 3) <span style="color: #483d8b;">:initial-element</span> nil))

</pre>
</div>

<p>
The functions AREF and SETF allow us to access elements and set them
with values:
st
</p>
<div class="org-src-container">
<pre class="src src-lisp">
<span style="color: #b22222;">;; </span><span style="color: #b22222;">Returns NIL</span>

(aref my-array 0 0)


<span style="color: #b22222;">;; </span><span style="color: #b22222;">Set (0,0) to B</span>

(setf (aref my-array 0 0) 'b)


<span style="color: #b22222;">;; </span><span style="color: #b22222;">Returns B</span>

(aref my-array 0 0)

</pre>
</div>

<p>
The functions ARRAY-RANK and ARRAY-DIMENSION retrieve the the number
of dimensions and the number of elements in a given dimension
respectively:
</p>

<div class="org-src-container">
<pre class="src src-lisp">
(setf my-array
      (make-array '(2 3)
                  <span style="color: #483d8b;">:initial-element</span> '((1 2 3) (1 2 3))))


<span style="color: #b22222;">;; </span><span style="color: #b22222;">Returns 2</span>

(array-rank my-array))


<span style="color: #b22222;">;; </span><span style="color: #b22222;">Returns 2</span>

(array-dimension my-array 0)


<span style="color: #b22222;">;; </span><span style="color: #b22222;">Returns 3</span>

(array-dimension my-array 1)

</pre>
</div>

<p>
We use :INITIAL-ELEMENT to set the value of every element of an array
to the provided argument, while we use :INITIAL-CONTENTS to set the
array to the object provided. A one-dimensional array is a vector and
can be created with either of the following.
</p>

<div class="org-src-container">
<pre class="src src-lisp">
(vector <span style="color: #8b2252;">"a"</span> 'b 3)
 
(<span style="color: #a020f0;">defparameter</span> <span style="color: #a0522d;">my-vector</span>
  (make-array 3 <span style="color: #483d8b;">:initial-contents</span> '(<span style="color: #8b2252;">"a"</span> 'b 3)))

</pre>
</div>

<p>
Finally, we can create a literal array using the #na syntax, where n
is the number of dimensions:
</p>

<div class="org-src-container">
<pre class="src src-lisp">
<span style="color: #b22222;">;; </span><span style="color: #b22222;">Returns ((B NIL NIL) (1 2 3))</span>

#2a((b nil nil) (1 2 3))

</pre>
</div>

<p>
Strings are vectors of characters, denoted with double quotes
(e.g. "my-string"). Strings evaluate to themselves. A character such
as c is denoted as #\c. Each character has an associated integer that
is usually (but not necessarily) its ASCII number:
</p>

<div class="org-src-container">
<pre class="src src-lisp">
<span style="color: #b22222;">;; </span><span style="color: #b22222;">Returns 99</span>

(char-code #\c)

<span style="color: #b22222;">;; </span><span style="color: #b22222;">Returns #\c</span>

(code-char 99) 

</pre>
</div>

<div id="outline-container-org293e5c5" class="outline-2">
<h2 id="org293e5c5">Sequences</h2>
<div class="outline-text-2" id="text-org293e5c5">
<p>
The type sequence includes both lists and vectors (and therefore
strings). Sequences have many useful functions:
</p>

<div class="org-src-container">
<pre class="src src-lisp">
<span style="color: #b22222;">;; </span><span style="color: #b22222;">Returns 6</span>

(length '(a b c d e f))

<span style="color: #b22222;">;; </span><span style="color: #b22222;">Returns (F E D C B A)</span>

(reverse '(a b c d e f)) 

<span style="color: #b22222;">;; </span><span style="color: #b22222;">Returns (C R T) (a new original list unaffected):</span>

(remove 'a '(c a r a t))

<span style="color: #b22222;">;; </span><span style="color: #b22222;">Returns "cbdra" (preserves only the last of each):</span>

(remove-duplicates <span style="color: #8b2252;">"abracadabra"</span>)

</pre>
</div>

<p>
We use SUBSEQ to get a portion of a list. Its arguments are a list,
the starting position and an optional ending position (which is not to
be included in the subsequence):
</p>

<div class="org-src-container">
<pre class="src src-lisp">
<span style="color: #b22222;">;; </span><span style="color: #b22222;">Returns (B C D)</span>

(subseq '(a b c d e f) 1 4)

</pre>
</div>

<p>
SORT takes a sequence and a comparison function of two arguments and
destructively (i.e. by modifying the original sequence) returns a
sequence sorted according to the function:
</p>

<div class="org-src-container">
<pre class="src src-lisp">
<span style="color: #b22222;">;; </span><span style="color: #b22222;">Returns (6 5 4 2 1)</span>

(sort '(1 4 2 5 6) #'&gt;) 

</pre>
</div>

<p>
The functions EVERY and SOME test whether a sequence satisfies a
provided predicate:
</p>

<div class="org-src-container">
<pre class="src src-lisp">
<span style="color: #b22222;">;; </span><span style="color: #b22222;">Returns NIL</span>

(every #'oddp '( 1 2 5)) 

<span style="color: #b22222;">;; </span><span style="color: #b22222;">Returns T</span>

(some #'oddp '( 1 2 5))

<span style="color: #b22222;">;; </span><span style="color: #b22222;">Returns T</span>

(every #'&gt; '(1 3 5) '(0 2 4))

</pre>
</div>
</div>
</div>


<div id="outline-container-orge9f920f" class="outline-2">
<h2 id="orge9f920f">Keyword Arguments</h2>
<div class="outline-text-2" id="text-orge9f920f">
<p>
Many sequence functions take one or more keyword arguments from the
below table. For example, we can use POSITION to return the position
of an element within a sequence (or NIL if not found) and use keyword
arguments to determine where to begin the search:
</p>

<p>
(position #\a "fantasia" :start 3 :end 7) ; Returns 4
</p>

<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Parameter</th>
<th scope="col" class="org-left">Position</th>
<th scope="col" class="org-left">Default</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">:key</td>
<td class="org-left">A function to apply to each element</td>
<td class="org-left">identity</td>
</tr>

<tr>
<td class="org-left">:test</td>
<td class="org-left">The test function for comparison</td>
<td class="org-left">eql</td>
</tr>

<tr>
<td class="org-left">:from-end</td>
<td class="org-left">If true, work backwards</td>
<td class="org-left">nil</td>
</tr>

<tr>
<td class="org-left">:start</td>
<td class="org-left">Position at which to start</td>
<td class="org-left">0</td>
</tr>

<tr>
<td class="org-left">:end</td>
<td class="org-left">Position, if any, at which to stop</td>
<td class="org-left">nil</td>
</tr>
</tbody>
</table>


<p>
The function REDUCE is useful to extend functions that only take two
variables. It takes two arguments, a function (which must take exactly
two values) and a sequence. The function is initially called on the
first two elements of the sequence, and thereafter with each
successive element as the second argument. The value returned by the
last call is the value returned by the REDUCE function. For example,
the below returns (A), the intersection of these three lists:
</p>

<div class="org-src-container">
<pre class="src src-lisp">
(reduce #'intersection '((b r a d) (b a d) (c a t)))

</pre>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="Date">Last updated: 24 July 2021</p><script src="/scripts/main.js"></script>
</div>
</body>
</html>
